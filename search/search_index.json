{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"SuperSaaS Auth Connector","text":"<p>Create a user in SuperSaas and login them in once identified via OIDC.</p> <ul> <li>Uses the official SuperSaaS Python library</li> <li>Tested with Keycloak 26</li> <li>Creates users in SuperSaaS after identifying them via Keycloak</li> <li>Forwards users to SuperSaaS once created</li> <li>Supports triggering a front-channel logout in Keycloak</li> </ul> <p>The aim is to allow convenient onboarding for users with access to Keycloak, while still allowing additional cloud-managed users in SuperSaaS itself as needed.</p> <p>The application is delivered as a simple container images, containing a simple Starlette app that implements the business logic.</p> <p>It is strongly recommended that you deploy the service as SuperSaaS Me if you choose to run your own.</p>"},{"location":"#installation","title":"Installation","text":"<p>Run the <code>ghcr.io/radiorabe/supersaasauthconnector:latest</code> in your preferred container runtime.</p> <p>Configuration is done via ENV variables.</p> Variable Default DEBUG False SSO_SERVER_URL https://sso.rabe.ch/auth/ SSO_REALM rabe SSO_CLIENT_ID supersaas-auth-connector ERROR_REDIRECT_URL https://www.rabe.ch LOGOUT_REDIRECT_URL https://sso.rabe.ch/auth/realms/rabe/protocol/openid-connect/logout?redirect_uri=https%3A%2F%2Fwww.rabe.ch SUPERSAAS_ACCOUNT_NAME RaBe SUPERSAAS_API_TOKEN PORT 8000 HOST 127.0.0.1 URL http://localhost:8000 SECRET_KEY supersecretkey <p>If you are not RaBe you will have to override most of these, if you are RaBe only some.</p> <p>On the Keycloak side the configuration is fairly trivial. The client needs to be public. We use the email claim from the jwt as well as an additional uid claim that you have to map in Keycloak. Other than that there are no special requirements and you are free to implement your own roles and scopes as required.</p>"},{"location":"#development","title":"Development","text":"<pre><code>python -mvenv venv\n. venv/bin/activate\n\npython -mpip install poetry\n\npoetry install\n\npoetry run pytest\n\nruff check\nruff format\n</code></pre>"},{"location":"#release-management","title":"Release Management","text":"<p>The CI/CD setup uses semantic commit messages following the conventional commits standard. The workflow is based on the RaBe shared actions and uses go-semantic-commit to create new releases.</p> <p>The commit message should be structured as follows:</p> <pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre> <p>The commit contains the following structural elements, to communicate intent to the consumers of your library:</p> <ol> <li>fix: a commit of the type <code>fix</code> patches gets released with a PATCH version bump</li> <li>feat: a commit of the type <code>feat</code> gets released as a MINOR version bump</li> <li>BREAKING CHANGE: a commit that has a footer <code>BREAKING CHANGE:</code> gets released as a MAJOR version bump</li> <li>types other than <code>fix:</code> and <code>feat:</code> are allowed and don't trigger a release</li> </ol> <p>If a commit does not contain a conventional commit style message you can fix it during the squash and merge operation on the PR.</p>"},{"location":"#build-process","title":"Build Process","text":"<p>The CI/CD setup uses Docker build-push Action to publish container images. The workflow is based on the RaBe shared actions.</p>"},{"location":"#license","title":"License","text":"<p>This application is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, version 3 of the License.</p>"},{"location":"#copyright","title":"Copyright","text":"<p>Copyright (c) 2025 - 2027 Radio Bern RaBe</p>"}]}